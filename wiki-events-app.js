function initWikiEventsApp(sharedData) {
    const sidebar = document.querySelector('#app-wiki-events .sidebar');
    const loaderStatus = document.getElementById('loader-status-text-sidebar');
    const myMap = new ymaps.Map('wiki-map', { center: [55.796, 49.108], zoom: 6, controls: ['zoomControl'] });

    const initialCities = sharedData.initialCities;

    const BASE_DATA_URL = 'https://cdn.jsdelivr.net/gh/Kudinov1982/history-map/';
    const PROVINCES_GEOJSON = 'https://raw.githubusercontent.com/Kudinov1982/map/main/provinces_1897.geojson';
    const UYEZDS_GEOJSON = 'https://raw.githubusercontent.com/Kudinov1982/map/main/map_25022025.geojson';
    const DATA_CHUNKS = ['events_1700-1709.json','events_1710-1719.json','events_1720-1729.json','events_1730-1739.json','events_1740-1749.json','events_1750-1759.json','events_1760-1769.json','events_1770-1779.json','events_1780-1789.json','events_1790-1799.json','events_1800-1809.json','events_1810-1819.json','events_1820-1824.json','events_1825-1829.json','events_1830-1834.json','events_1835-1839.json','events_1845-1849.json','events_1850-1854.json','events_1854-1859.json','events_1860-1864.json','events_1865-1869.json','events_1870-1879.json','events_1880-1889.json','events_1890-1899.json','events_1900-1909.json','events_1910-1919.json','establishment_university.json','establishment_factory.json'];
    const minYear = 1700; const maxYear = 1919;
    const EVENT_TYPE_CONFIG = {birth:{name:"Рождения",svg:'<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="#D8334A" d="M13 3v7.267l6.294-3.633l1 1.732L14 11.999l6.294 3.635l-1 1.732l-6.295-3.634V21h-2v-7.268l-6.294 3.634l-1-1.732L9.998 12L3.705 8.366l1-1.732L11 10.267V3h2Z"/></svg>',category:"main"},death:{name:"Смерти",svg:'<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 64 64"><path fill="#333333" d="M55 32.001v-7.5H35.68V17h5.521V9.5H35.68V2h-7.36v7.5h-5.519V17h5.519v7.501H9v7.5h19.32v13.437l-7.359-3.125v7.5l7.359 3.125V62h7.36v-5.937l7.361 3.125v-7.5l-7.361-3.125V32.001z"/></svg>',category:"main"},battle:{name:"Сражения",svg:'<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="#8E44AD" d="m6.2 2.44l11.9 11.9l2.12-2.12l1.41 1.41l-2.47 2.47l3.18 3.18c.39.39.39 1.02 0 1.41l-.71.71a.996.996 0 0 1-1.41 0L17 18.23l-2.44 2.47l-1.41-1.41l2.12-2.12l-11.9-11.9V2.44H6.2M15.89 10l4.74-4.74V2.44H17.8l-4.74 4.74L15.89 10m-4.95 5l-2.83-2.87l-2.21 2.21l-2.12-2.12l-1.41 1.41l2.47 2.47l-3.18 3.19a.996.996 0 0 0 0 1.41l.71.71c.39.39 1.02.39 1.41 0L7 18.23l2.44 2.47l1.41-1.41l-2.12-2.12L10.94 15Z"/></svg>',category:"main"},construction:{name:"Строительство",svg:'<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 256 256"><path fill="green" d="m251.34 112l-67.46-67.92a96.1 96.1 0 0 0-135.77 0l-.09.09L34.25 58.4a8 8 0 0 0 11.49 11.13l13.73-14.18a79.92 79.92 0 0 1 18.71-13.9L124.68 88l-96 96a16 16 0 0 0 0 22.63l20.69 20.69a16 16 0 0 0 22.63 0l96-96l14.34 14.34L200 163.3a16 16 0 0 0 22.63 0l28.69-28.69a16 16 0 0 0 .02-22.61ZM60.68 216L40 195.31l68-68L128.68 148Zm101.66-101.68L140 136.67L119.31 116l22.35-22.35a8 8 0 0 0 0-11.32L94.32 35a80 80 0 0 1 78.23 20.41l44.22 44.51L188 128.66l-14.34-14.34a8 8 0 0 0-11.32 0Zm49 37.66l-12-12L228 111.25l12 12Z"/></svg>',category:"main"},establishment_university:{name:"Университеты",svg:'<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 16 16"><path fill="currentColor" d="M16 6.28a1.23 1.23 0 0 0-.62-1.07l-6.74-4a1.27 1.27 0 0 0-1.28 0l-6.75 4a1.25 1.25 0 0 0 0 2.15l1.92 1.12v2.81a1.28 1.28 0 0 0 .62 1.09l4.25 2.45a1.28 1.28 0 0 0 1.24 0l4.25-2.45a1.28 1.28 0 0 0 .62-1.09V8.45l1.24-.73v2.72H16V6.28zm-3.73 5L8 13.74l-4.22-2.45V9.22l3.58 2.13a1.29 1.29 0 0 0 1.28 0l3.62-2.16zM8 10.27l-6.75-4L8 2.26l6.75 4z"/></svg>',category:"establishments"},establishment_factory:{name:"Предприятия",svg:'<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 13.5V9c0-.943 0-1.414-.293-1.707S7.943 7 7 7H5c-.943 0-1.414 0-1.707.293S3 8.057 3 9v9c0 1.886 0 2.828.586 3.414S5.114 22 7 22h2m0-8.5l3.317-1.658c1.1-.55 1.65-.826 2.077-.643a1 1 0 0 1 .252.155c.354.3.354.915.354 2.146l3.106-1.553c1.297-.648 1.945-.973 2.42-.68s.474 1.019.474 2.47V18c0 1.886 0 2.828-.586 3.414S18.886 22 17 22H9m0-8.5V22M3 10h6m4-8H8c-.943 0-1.414 0-1.707.293S6 3.057 6 4m10-2h1m-6 3h6" color="currentColor"/></svg>',category:"establishments"},default:{name:"Прочее",color:"grey"}};
    const excludedGubIDs = new Set(['20','70','21','97','105','4','30','5','106','64','22','62a','70b','6','62b','70a','25','65','31','41','29','19','107','102','99','7','32','8','33','100','66','101','9','67','34','10','27','1','26','104','28','103','62']);
    let allEvents = []; let eventPlacemarks = new Map();
    const provincesCollection = new ymaps.GeoObjectCollection(null, { zIndex: 0 });
    const uyezdCollection = new ymaps.GeoObjectCollection(null, { zIndex: 80 });
    let uyezdCenterCollection = new ymaps.GeoObjectCollection(null, { zIndex: 100 });
    let placemarksCollection = new ymaps.GeoObjectCollection(null, {});
    myMap.geoObjects.add(provincesCollection).add(uyezdCollection).add(uyezdCenterCollection).add(placemarksCollection);
    let provincePolygons = new Map(); let provinceIndex = []; let cityCollection;
    const uyezdFeatures = []; const uezdsByProvince = new Map();
    let uyezdChoicesInstance = null; let provinceChoices;
    let currentVisibleEventIds = new Set();
    const updateLoaderStatus = (text) => loaderStatus.textContent = text;
    const provinceFilterEl = document.getElementById('province-filter');
    const uyezdFilterEl = document.getElementById('uyezd-filter');
    const startYearInput = document.getElementById('start-year-input');
    const endYearInput = document.getElementById('end-year-input');
    const applyDateFilterBtn = document.getElementById('apply-date-filter');
    const eventCounter = document.getElementById('event-counter');
    const typeFiltersMainContainer = document.getElementById('type-filters-main');
    const typeFiltersEstablishmentsContainer = document.getElementById('type-filters-establishments');
    const eventListContainer = document.getElementById('event-list');
    const shareButton = document.getElementById('share-button');
    function cleanCellText(txt) { return (txt || '').replace(/\[[^\]]*\]/g, '').replace(/\u00A0/g, ' ').replace(/\s+/g, ' ').trim(); }
    function normalizeSeparators(v) { return v.replace(/\s*:\s*/g, ': ').replace(/\s*,\s*/g, ', ').replace(/,\s*:\s*/g, ': ').replace(/:\s*,\s*/g, ': ').replace(/,\s*,/g, ', ').replace(/^[,:]\s*/, '').replace(/\s*[,:]\s*$/, '').replace(/\s+/g, ' ').trim(); }
    function normalizeAbbr(v) { return v.replace(/\b(г|с|д|п|р\.)\.\s*/gi, (m)=> m.replace(/\./g,'')+' '); }
    function normalizeLocationValue(raw) { let v = cleanCellText(raw); v = normalizeAbbr(v); v = normalizeSeparators(v); return v; }
    function stripHeaderEcho(value, header) { if (!value || !header) return value; const h = cleanCellText(header).toLowerCase(); let v = cleanCellText(value); const vLow = v.toLowerCase(); if (vLow.startsWith(h + ':')) return v.slice(header.length + 1).trim(); if (vLow.startsWith(h)) return v.slice(header.length).trim(); return v; }
    function normalizeOrgName(s) { return (s || '').replace(/[«»"“”„]/g, '').replace(/\b(АО|ПАО|ОАО|ЗАО|ООО|НАО|ПТ|АТ|АТП)\b\.?/gi, '').replace(/\(.*?\)/g, '').replace(/\s+/g, ' ').trim().toLowerCase(); }
    function looksLikeDuplicateOfName(locationText, name) { const loc = normalizeOrgName(locationText); const nm = normalizeOrgName(name); if (!loc || !nm) return false; return loc === nm || loc.includes(nm); }
    function extractFromInfobox(event) { if (!event.infobox_html) return ''; const tempDiv = document.createElement('div'); tempDiv.innerHTML = event.infobox_html; const searchCriteria = { birth: { keywords: ['место рождения','рождение'] }, death: { keywords: ['место смерти','смерть'] }, construction: { keywords: ['город','расположение','адрес','местоположение','место','село','деревня'] }, establishment_university: { keywords: ['расположение','адрес','город','местоположение','место','село','деревня'] }, establishment_factory: { keywords: ['расположение','адрес','город','местоположение','место','село','деревня'] }, default: { keywords: ['местоположение','место','локация','расположение','адрес','город'] } }; const search = searchCriteria[event.type] || searchCriteria.default; for (const keyword of search.keywords) { for (const row of tempDiv.querySelectorAll('tr')) { const th = row.querySelector('th'); if (!th) continue; const headerText = cleanCellText(th.textContent).toLowerCase(); if (headerText === keyword) { const td = row.querySelector('td'); if (td) { let val = td.textContent || ''; val = stripHeaderEcho(val, th.textContent || ''); val = normalizeLocationValue(val); if (val) return val; } } } } const coordsEl = tempDiv.querySelector('.coordinates'); if (coordsEl) { const coordsText = cleanCellText(coordsEl.textContent || ''); if (coordsText) return coordsText; } return ''; }
    function getLocationName(event) { const invalidRaw = (v) => !v || v === 'Без названия' || v === 'Российская империя'; if (!invalidRaw(event.location)) { let loc = normalizeLocationValue(event.location); loc = loc.replace(/:\s*,\s*/g, ': ').replace(/,\s*:\s*/g, ': '); if (!looksLikeDuplicateOfName(loc, event.name)) return loc; } const box = extractFromInfobox(event); if (box && !looksLikeDuplicateOfName(box, event.name)) return box; return ''; }
    function computeLocationIfNeeded(event) { if (event.cachedLocation !== undefined) return event.cachedLocation; event.cachedLocation = getLocationName(event) || ''; if (event.cachedLocation) event._location_lc = event.cachedLocation.toLowerCase(); return event.cachedLocation; }
    function renderFilters() { const defaultActiveTypes = ['birth','battle','construction']; let mainFiltersHtml = ''; let establishmentFiltersHtml = ''; Object.entries(EVENT_TYPE_CONFIG).forEach(([type, config]) => { if (type === 'default') return; const isChecked = defaultActiveTypes.includes(type) ? 'checked' : ''; const icon = config.svg || ''; const filterHtml = `<div class="filter-item"><input type="checkbox" id="filter-${type}" value="${type}" ${isChecked}>${icon}<label for="filter-${type}">${config.name}</label></div>`; if (config.category === 'establishments') establishmentFiltersHtml += filterHtml; else mainFiltersHtml += filterHtml; }); typeFiltersMainContainer.innerHTML = mainFiltersHtml; typeFiltersEstablishmentsContainer.innerHTML = establishmentFiltersHtml; document.querySelectorAll('#app-wiki-events input[type="checkbox"]').forEach(cb => cb.addEventListener('change', updateUI)); }
    let updateToken = 0; async function updateUI() { const myToken = ++updateToken; applyDateFilterBtn.classList.add('is-loading'); applyDateFilterBtn.disabled = true; await new Promise(r => requestAnimationFrame(r)); let startYear = parseInt(startYearInput.value, 10) || minYear; let endYear = parseInt(endYearInput.value, 10) || maxYear; if (startYear > endYear) { [startYear, endYear] = [endYear, startYear]; startYearInput.value = startYear; endYearInput.value = endYear; } const activeTypes = Array.from(document.querySelectorAll('#app-wiki-events input[type="checkbox"]:checked')).map(cb => cb.value); const activeTypesSet = new Set(activeTypes); const selectedProvince = provinceFilterEl.value; const selectedUyezd = uyezdFilterEl.value; const filteredEvents = allEvents.filter(event => { if (event.year < startYear || event.year > endYear) return false; if (!activeTypesSet.has(event.type)) return false; if (selectedProvince && event.province !== selectedProvince) return false; if (selectedUyezd && event.uyezd !== selectedUyezd) return false; return true; }); filteredEvents.sort((a, b) => a.year - b.year || (a._name_lc > b._name_lc ? 1 : a._name_lc < b._name_lc ? -1 : 0)); if (myToken !== updateToken) return; await updateMap(filteredEvents); if (myToken !== updateToken) return; await renderEventListBatched(filteredEvents); updateUyezdPolygonsVisibility(); updateUrlState(); if (myToken !== updateToken) return; applyDateFilterBtn.classList.remove('is-loading'); applyDateFilterBtn.disabled = false; }
    function createIconLayout(svg, highlighted=false) { const cls = highlighted ? 'custom-svg-icon is-highlighted' : 'custom-svg-icon'; return ymaps.templateLayoutFactory.createClass(`<div class="${cls}">${svg || ''}</div>`); }
    function highlightPlacemarkByEventId(eventId, on=true) { const pm = eventPlacemarks.get(eventId); if (!pm) return; pm.options.set('iconLayout', on ? pm.__hiLayout : pm.__normalLayout); pm.options.set('zIndex', on ? 10000 : 200); }
    async function addPlacemarksBatch(toAdd) { const batchSize = 400; for (let i = 0; i < toAdd.length; i += batchSize) { const slice = toAdd.slice(i, i + batchSize); for (const event of slice) { if (eventPlacemarks.has(event.id)) continue; const iconConfig = EVENT_TYPE_CONFIG[event.type] || EVENT_TYPE_CONFIG['default']; const normalLayout = createIconLayout(iconConfig.svg, false); const hiLayout = createIconLayout(iconConfig.svg, true); const placemark = new ymaps.Placemark([event.lat, event.lon], { balloonContent: '<div class="custom-balloon__body"><div class="custom-balloon__title">Загрузка...</div></div>', hintContent: `${event.name} (${event.year})` }, { iconLayout: normalLayout, iconShape: { type: 'Circle', coordinates: [14, 14], radius: 14 }, zIndex: 200, hideIconOnBalloonOpen: false }); placemark.__normalLayout = normalLayout; placemark.__hiLayout = hiLayout; placemark.events.add('balloonopen', () => { const html = buildBalloonHtml(event); placemark.properties.set('balloonContent', html); const li = listItemsById.get(event.id); if (li) { eventListContainer.querySelectorAll('.event-item.is-active').forEach(x=>x.classList.remove('is-active')); li.classList.add('is-active'); li.scrollIntoView({ behavior:'smooth', block:'center' }); } }); eventPlacemarks.set(event.id, placemark); placemarksCollection.add(placemark); } await new Promise(r => (window.requestIdleCallback ? requestIdleCallback(r) : setTimeout(r, 0))); } }
    function removePlacemarksByIds(ids) { const toRemove = []; ids.forEach(id => { const pm = eventPlacemarks.get(id); if (pm) { toRemove.push(pm); eventPlacemarks.delete(id); } }); if (toRemove.length) toRemove.forEach(pm => placemarksCollection.remove(pm)); }
    async function updateMap(events) { const newVisible = new Set(events.map(e => e.id)); const toRemoveIds = []; currentVisibleEventIds.forEach(id => { if (!newVisible.has(id)) toRemoveIds.push(id); }); removePlacemarksByIds(toRemoveIds); const toAdd = events.filter(e => !currentVisibleEventIds.has(e.id)); await addPlacemarksBatch(toAdd); currentVisibleEventIds = newVisible; }
    function buildBalloonHtml(event) { let headerHtml = ''; let cleanedInfoboxHtml = ''; if (event.infobox_html) { const tempDiv = document.createElement('div'); tempDiv.innerHTML = event.infobox_html; const image = tempDiv.querySelector('img.mw-file-element'); if (image && image.src) { headerHtml = `<div class="custom-balloon__header" style="background-image: url(${image.src})"></div>`; const imageRow = image.closest('tr'); if (imageRow) imageRow.remove(); } const caption = tempDiv.querySelector('caption'); if (caption) caption.remove(); const firstRow = tempDiv.querySelector('tbody > tr'); if (firstRow && firstRow.children.length === 1 && firstRow.querySelector('th')) firstRow.remove(); cleanedInfoboxHtml = tempDiv.innerHTML; } const iconConfig = EVENT_TYPE_CONFIG[event.type] || EVENT_TYPE_CONFIG['default']; const actionLinkHtml = event.wiki_url ? `<a href="${event.wiki_url}" target="_blank" class="custom-balloon__action-link">Читать в Википедии</a>` : ''; return `<div class="custom-balloon">${headerHtml}<div class="custom-balloon__body"><div class="custom-balloon__title">${event.name}</div><div class="custom-balloon__meta"><div class="custom-balloon__meta-item"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="#6b7280" viewBox="0 0 16 16"><path d="M11 6.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm-3 0a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1z"/><path d="M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2z"/></svg><span>${event.year}</span></div><div class="custom-balloon__meta-item"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="#6b7280" viewBox="0 0 16 16"><path d="M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2z"/></svg><span>${iconConfig.name}</span></div></div><div class="custom-balloon__extract">${event.extract || ''}</div>${cleanedInfoboxHtml}${actionLinkHtml}</div></div>`; }
    const listItemsById = new Map(); async function renderEventListBatched(events) { eventListContainer.innerHTML = ''; listItemsById.clear(); eventCounter.textContent = `Найдено событий: ${events.length}`; if (events.length === 0) { eventListContainer.innerHTML = '<div class="event-item-empty">Событий не найдено.<br>Попробуйте изменить фильтры.</div>'; return; } const batchSize = 400; for (let i = 0; i < events.length; i += batchSize) { const frag = document.createDocumentFragment(); const slice = events.slice(i, i + batchSize); for (const event of slice) { if (event.cachedLocation === undefined) computeLocationIfNeeded(event); const loc = event.cachedLocation || ''; const item = document.createElement('div'); item.className = 'event-item'; item.dataset.eventId = String(event.id); item.innerHTML = `<div class="event-item-header"><span class="event-item-year">${event.year}</span><span class="event-item-name">${event.name}</span></div><div class="event-item-location">${loc}</div>`; item.addEventListener('mouseenter', () => highlightPlacemarkByEventId(event.id, true)); item.addEventListener('mouseleave', () => highlightPlacemarkByEventId(event.id, false)); item.addEventListener('click', () => { const placemark = eventPlacemarks.get(event.id); if (placemark) { myMap.panTo(placemark.geometry.getCoordinates(), { duration: 500, flying: true }).then(() => { if (!placemark.balloon.isOpen()) placemark.balloon.open(); }); } }); listItemsById.set(event.id, item); frag.appendChild(item); } eventListContainer.appendChild(frag); await new Promise(r => requestAnimationFrame(r)); } }
    async function loadProvinces() { const response = await fetch(PROVINCES_GEOJSON); if (!response.ok) throw new Error(`Ошибка загрузки GeoJSON: ${response.status}`); const geojsonData = await response.json(); provincesCollection.removeAll(); provincePolygons.clear(); geojsonData.features.forEach(feature => { const provinceName = feature.properties.prov_RU; const provinceID = feature.properties.Gub_ID; if (!provinceName || excludedGubIDs.has(String(provinceID))) return; let coordinates; if (feature.geometry.type === 'Polygon') { coordinates = [ feature.geometry.coordinates.map(ring => ring.map(coord => [coord[1], coord[0]])) ]; } else if (feature.geometry.type === 'MultiPolygon') { coordinates = feature.geometry.coordinates.map(poly => poly.map(ring => ring.map(coord => [coord[1], coord[0]]))); } if (coordinates) { const polygon = new ymaps.Polygon([].concat(...coordinates), {}, { fillColor: '#20808C', strokeColor: '#eeeeee', strokeWidth: 1.5, fillOpacity: 0.35, interactivityModel: 'default#transparent' }); provincesCollection.add(polygon); provincePolygons.set(provinceName, polygon); } }); myMap.geoObjects.add(provincesCollection); populateProvinceFilter(); provinceIndex = Array.from(provincePolygons.entries()).map(([name, polygon]) => { const b = polygon.geometry.getBounds(); return { name, polygon, bbox: { minLat: b[0][0], minLon: b[0][1], maxLat: b[1][0], maxLon: b[1][1] } }; }); }
    function bboxContains(b, lat, lon) { return lat >= b.minLat && lat <= b.maxLat && lon >= b.minLon && lon <= b.maxLon; }
    async function loadUyezds() { updateLoaderStatus('Загрузка: Уезды…'); const res = await fetch(UYEZDS_GEOJSON, { cache:'force-cache' }); if (!res.ok) throw new Error('Uyezds GeoJSON HTTP ' + res.status); const data = await res.json(); uyezdCollection.removeAll(); uyezdFeatures.length = 0; uezdsByProvince.clear(); (data.features || []).forEach((f, idx) => { const props = f.properties || {}; const name = props.Name_RU; const prov = props.prov_RU; if (!name || !prov) return; const contours = []; if (f.geometry && f.geometry.type === 'Polygon') (f.geometry.coordinates || []).forEach(ring => { contours.push(ring.map(c => [c[1], c[0]])); }); else if (f.geometry && f.geometry.type === 'MultiPolygon') (f.geometry.coordinates || []).forEach(poly => { (poly || []).forEach(ring => { contours.push(ring.map(c => [c[1], c[0]])); }); }); else return; const polygon = new ymaps.Polygon(contours, { name, prov, id: f.id ?? ('_u_'+idx) }, { zIndex: 80, fillColor: '#9aa8b5', fillOpacity: 0.18, strokeColor: '#6b7280', strokeOpacity: 0.7, strokeWidth: 1.2, interactivityModel:'default#transparent', visible: true }); uyezdCollection.add(polygon); const b = polygon.geometry.getBounds(); const feature = { id: polygon.properties.get('id'), name, province: prov, polygon, bbox: { minLat:b[0][0], minLon:b[0][1], maxLat:b[1][0], maxLon:b[1][1] } }; uyezdFeatures.push(feature); if (!uezdsByProvince.has(prov)) uezdsByProvince.set(prov, []); uezdsByProvince.get(prov).push({ id: feature.id, name: feature.name }); }); }
    function computeUyezdsFor(items) { if (!items?.length || !uyezdFeatures.length) return; for (const it of items) { if (it.uyezd) continue; let candidates = uyezdFeatures; if (it.province && uezdsByProvince.has(it.province)) { const names = new Set(uezdsByProvince.get(it.province).map(x => x.name)); candidates = uyezdFeatures.filter(u => u.province === it.province && names.has(u.name)); } const bboxCand = candidates.filter(u => bboxContains(u.bbox, it.lat, it.lon)); const hit = bboxCand.find(u => u.polygon.geometry.contains([it.lat, it.lon])); if (hit) it.uyezd = hit.name; } }
    function populateUyezdFilter(selectedProvince) { if (!uyezdChoicesInstance) return; const baseChoice = [{ value:'', label:'Все уезды', selected:true }]; if (!selectedProvince || !uezdsByProvince.has(selectedProvince)) { uyezdChoicesInstance.setChoices([{ value:'', label:'Сначала выберите губернию', selected:true, disabled:true }], 'value','label', true); uyezdFilterEl.disabled = true; return; } const list = uezdsByProvince.get(selectedProvince).slice().sort((a,b)=>a.name.localeCompare(b.name,'ru')).map(u => ({ value:u.name, label:u.name })); uyezdChoicesInstance.clearStore(); uyezdChoicesInstance.setChoices(baseChoice.concat(list), 'value', 'label', true); uyezdFilterEl.disabled = false; }
    function updateUyezdPolygonsVisibility() { const selProv = provinceFilterEl.value; const selUyezd = uyezdFilterEl.value; for (const uf of uyezdFeatures) { let visible = true; if (selProv && uf.province !== selProv) visible = false; if (selUyezd && uf.name !== selUyezd) visible = false; uf.polygon.options.set('visible', visible); } }
    function addCityPlacemarks() { if (!cityCollection) { cityCollection = new ymaps.GeoObjectCollection(null, { zIndex: 100 }); myMap.geoObjects.add(cityCollection); } cityCollection.removeAll(); const zoom = myMap.getZoom(); initialCities.forEach(city => { const shouldShow = (zoom >= 7) || (zoom >= 6 && city.priority <= 2) || (zoom >= 5 && city.priority === 1); if (!shouldShow) return; let radius, fontSize, fontWeight; switch (city.priority) { case 1: radius = zoom <= 5 ? 4 : 5; fontSize = 13; fontWeight = 700; break; case 2: radius = zoom <= 5 ? 3 : 4; fontSize = 12; fontWeight = 500; break; default: radius = zoom <= 6 ? 2.5 : 3.5; fontSize = 11; fontWeight = 400; break; } const iconSize = radius * 2; const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${iconSize}" height="${iconSize}" viewBox="0 0 ${iconSize} ${iconSize}"><circle cx="${radius}" cy="${radius}" r="${radius-0.5}" fill="${city.priority===1?'#FF4136':'#FF851B'}" stroke="#fff" stroke-width="1" opacity="0.9"/></svg>`; const placemark = new ymaps.Placemark([city.lat, city.lng], { iconContent: `<span class="map-label-text" style="font-size: ${fontSize}px; font-weight: ${fontWeight};">${city.displayName||city.name}</span>` }, { iconLayout:'default#imageWithContent', iconImageHref:'data:image/svg+xml;base64,'+btoa(svg), iconImageSize:[iconSize,iconSize], iconImageOffset:[-radius,-radius], iconContentOffset:[radius+4,-iconSize+(radius-fontSize/2)], iconContentLayout: ymaps.templateLayoutFactory.createClass('$[properties.iconContent]'), hideIconOnBalloonOpen:false, interactivityModel:'default#transparent' }); cityCollection.add(placemark); }) }
    function updateLabels() { addCityPlacemarks(); }
    function populateProvinceFilter() { const provinceNames = Array.from(provincePolygons.keys()).sort((a, b) => a.localeCompare(b, 'ru')); const choicesArray = provinceNames.map(name => ({ value: name, label: name })); choicesArray.unshift({ value: '', label: 'Все губернии', selected: true }); if (provinceChoices) provinceChoices.destroy(); provinceChoices = new Choices(provinceFilterEl, { choices: choicesArray, searchEnabled: true, itemSelectText: '', noResultsText: 'Не найдено', shouldSort: false, allowHTML: false, position: 'bottom' }); if (uyezdChoicesInstance) uyezdChoicesInstance.destroy(); uyezdChoicesInstance = new Choices(uyezdFilterEl, { choices: [{ value:'', label:'Сначала выберите губернию', selected:true, disabled:true }], searchEnabled:true, itemSelectText:'', shouldSort:false, allowHTML:false, position:'bottom' }); uyezdFilterEl.disabled = true; }
    function handleProvinceChange(options = {}) { const { isInitial = false } = options; const sel = provinceFilterEl.value; provincePolygons.forEach((poly, name) => { poly.options.set('visible', !sel || name === sel); }); populateUyezdFilter(sel); if (uyezdChoicesInstance) { uyezdChoicesInstance.setChoiceByValue(''); } else { uyezdFilterEl.value = ''; } if (sel) { const poly = provincePolygons.get(sel); if (poly) myMap.setBounds(poly.geometry.getBounds(), { checkZoomRange:true, duration: isInitial ? 0 : 700, zoomMargin:40 }); } else { myMap.setCenter([55.796,49.108], 6, { duration: isInitial ? 0 : 700 }); } updateLabels(); updateUI(); }
    function handleUyezdChange(options = {}) { const { isInitial = false } = options; const selU = uyezdFilterEl.value; if (selU) { const uf = uyezdFeatures.find(x => x.name === selU && x.province === provinceFilterEl.value); if (uf) myMap.setBounds(uf.polygon.getBounds(), { checkZoomRange:true, duration: isInitial ? 0 : 700, zoomMargin:40 }); } updateUI(); }
    function updateUrlState() { const selProv = provinceFilterEl.value; const selUyezd = uyezdFilterEl.value; const startYear = startYearInput.value; const endYear = endYearInput.value; const activeTypes = Array.from(document.querySelectorAll('#app-wiki-events input[type="checkbox"]:checked')).map(cb => cb.value); const url = new URL(window.location); url.searchParams.delete('province'); url.searchParams.delete('uyezd'); url.searchParams.delete('types'); url.searchParams.delete('start_year'); url.searchParams.delete('end_year'); if (selProv) url.searchParams.set('province', selProv); if (selUyezd) url.searchParams.set('uyezd', selUyezd); if (activeTypes.length > 0) url.searchParams.set('types', activeTypes.join(',')); if (startYear) url.searchParams.set('start_year', startYear); if (endYear) url.searchParams.set('end_year', endYear); window.history.replaceState({}, '', url); }
    async function fetchJsonWithRetry(url, attempts = 2) { for (let i = 0; i < attempts; i++) { try { const res = await fetch(url, { cache: 'force-cache' }); if (!res.ok) throw new Error(`HTTP ${res.status}`); const text = await res.text(); return JSON.parse(text); } catch (e) { if (i === attempts - 1) throw e; await new Promise(r => setTimeout(r, 300)); } } }
    async function loadAllData() { const chunkUrls = DATA_CHUNKS.map(c => `${BASE_DATA_URL}${c}?v=1`); const concurrency = 4; let index = 0; let successfulEvents = []; let hasErrors = false; async function worker() { while (index < chunkUrls.length) { const myIndex = index++; const url = chunkUrls[myIndex]; try { const data = await fetchJsonWithRetry(url, 2); successfulEvents.push(...data); } catch (e) { console.error('Не удалось загрузить чанк:', url, e); hasErrors = true; } await new Promise(r => setTimeout(r, 0)); } } const workers = Array.from({ length: concurrency }, worker); await Promise.all(workers); if (successfulEvents.length === 0 && hasErrors) { throw new Error('Не удалось загрузить ни один файл с данными.'); } const eventsWithWiki = successfulEvents.filter(e => e.wiki_url); for (const event of eventsWithWiki) { if (typeof event.name === 'string') event._name_lc = event.name.toLowerCase(); if (typeof event.extract === 'string') event._extract_lc = event.extract.toLowerCase(); } allEvents = eventsWithWiki; }
    async function precomputeEventRegionsAsync() { if (provinceIndex.length === 0) return; updateLoaderStatus('Анализ расположения...'); const total = allEvents.length; const chunkSize = 1000; for (let i = 0; i < total; i += chunkSize) { const chunk = allEvents.slice(i, i + chunkSize); for (const event of chunk) { const candidates = provinceIndex.filter(p => bboxContains(p.bbox, event.lat, event.lon)); const found = candidates.find(p => p.polygon.geometry.contains([event.lat, event.lon])); if (found) event.province = found.name; } computeUyezdsFor(chunk); updateLoaderStatus(`Анализ расположения: ${Math.min(i + chunkSize, total)} / ${total}`); await new Promise(r => setTimeout(r, 0)); } }
    
    async function run() {
        sidebar.classList.add('is-loading');
        updateLoaderStatus('Инициализация...');
        renderFilters();
        try {
            const urlParams = new URLSearchParams(window.location.search);
            const provinceFromUrl = urlParams.get('province'); const uyezdFromUrl = urlParams.get('uyezd');
            const typesFromUrl = urlParams.get('types'); const startYearFromUrl = urlParams.get('start_year'); const endYearFromUrl = urlParams.get('end_year');
            if (typesFromUrl !== null) { const activeTypes = new Set(typesFromUrl.split(',').filter(Boolean)); document.querySelectorAll('#app-wiki-events input[type="checkbox"]').forEach(cb => { cb.checked = activeTypes.has(cb.value); }); }
            startYearInput.value = startYearFromUrl || 1800; endYearInput.value = endYearFromUrl || 1801;
            updateLoaderStatus('Загрузка событий...'); await loadAllData();
            updateLoaderStatus('Загрузка губерний...'); await loadProvinces();
            await loadUyezds();
            addCityPlacemarks();
            await precomputeEventRegionsAsync();
            provinceFilterEl.addEventListener('change', () => handleProvinceChange());
            uyezdFilterEl.addEventListener('change', () => handleUyezdChange());
            applyDateFilterBtn.addEventListener('click', updateUI);
            myMap.events.add('boundschange', (e) => { if (e.get('newZoom') !== e.get('oldZoom')) updateLabels(); });
            const checkmarkSVG = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="m9.55 18l-5.7-5.7l1.425-1.425L9.55 15.15l9.175-9.175L20.15 7.4L9.55 18Z"/></svg>';
            shareButton.addEventListener('click', () => { navigator.clipboard.writeText(window.location.href).then(() => { const originalSVG = shareButton.innerHTML; shareButton.innerHTML = checkmarkSVG; shareButton.disabled = true; setTimeout(() => { shareButton.innerHTML = originalSVG; shareButton.disabled = false; }, 2500); }).catch(err => { console.error('Не удалось скопировать ссылку: ', err); alert('Не удалось скопировать ссылку.'); }); });
            if (provinceFromUrl && provinceChoices) { provinceChoices.setChoiceByValue(provinceFromUrl); handleProvinceChange({ isInitial: true }); if (uyezdFromUrl && uyezdChoicesInstance) { setTimeout(() => { uyezdChoicesInstance.setChoiceByValue(uyezdFromUrl); handleUyezdChange({ isInitial: true }); }, 150); } } else { await updateUI(); }
        } catch (error) { console.error("Критическая ошибка при загрузке:", error); updateLoaderStatus(`Ошибка: ${error.message}. Перезагрузите страницу.`); return; }
        finally { sidebar.classList.remove('is-loading'); }
    }
    run();
    return myMap; 
}
